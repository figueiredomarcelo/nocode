<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tic Tac Toe — TV (1080p, Remote + SFX)</title>
  <style>
    :root {
      --bg: #0a0a0a;
      --panel: #121212;
      --accent: #00d4ff;
      --accent-dim: #009bb8;
      --text: #ffffff;
      --text-dim: #c7c7c7;
      --x-color: #ff4d4f;
      --o-color: #4caf50;
      --grid-border: #2a2a2a;
      --safe-margin: 56px; /* TV safe area */
    }

    html, body { height: 100%; }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Noto Sans", Arial, sans-serif;
      cursor: none;
      overflow: hidden;
    }

    .tv-stage {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: radial-gradient(1000px 600px at 50% 35%, #101010 0%, var(--bg) 65%);
    }

    .canvas-16x9 {
      aspect-ratio: 16 / 9;
      width: 100vw;
      height: 100vh;
      max-width: 100vw;
      max-height: 100vh;
      display: grid;
      grid-template-rows: auto 1fr auto;
      box-sizing: border-box;
      padding: var(--safe-margin);
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 24px;
      padding-bottom: 16px;
    }
    .title {
      font-size: 56px;
      font-weight: 800;
      letter-spacing: 0.5px;
    }
    .controls-hint {
      font-size: 28px;
      color: var(--text-dim);
    }

    .main {
      display: grid;
      grid-template-columns: 1fr 680px;
      gap: 48px;
      align-items: center;
      justify-items: center;
    }

    .info-panel {
      width: 100%;
      max-width: 960px;
      background: linear-gradient(180deg, #141414 0%, #0e0e0e 100%);
      border: 1px solid #1f1f1f;
      border-radius: 24px;
      padding: 32px 36px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }

    .status { font-size: 44px; margin-bottom: 16px; }
    .substatus { font-size: 28px; color: var(--text-dim); }

    .grid {
      width: 680px;
      height: 680px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      background: var(--panel);
      border-radius: 24px;
      overflow: hidden;
      border: 2px solid var(--grid-border);
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    }

    .cell {
      display: grid;
      place-items: center;
      border: 2px solid var(--grid-border);
      font-size: 160px;
      font-weight: 800;
      user-select: none;
      color: var(--text);
      transition: transform 120ms ease, background 120ms ease, box-shadow 120ms ease;
    }
    .cell.X { color: var(--x-color); }
    .cell.O { color: var(--o-color); }

    .cell.selected {
      outline: none;
      background: rgba(0, 212, 255, 0.10);
      box-shadow: inset 0 0 0 6px var(--accent);
      transform: scale(1.02);
    }

    .cell.winning {
      background: rgba(255, 215, 0, 0.12);
      box-shadow: inset 0 0 0 8px #ffd700;
    }

    footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: var(--text-dim);
      font-size: 24px;
      padding-top: 16px;
    }

    .overlay {
      position: fixed;
      inset: 0;
      display: none;
      place-items: center;
      background: rgba(0,0,0,0.6);
      backdrop-filter: blur(8px);
    }
    .overlay.show { display: grid; }
    .menu {
      width: 800px;
      background: #121212;
      border: 1px solid #2a2a2a;
      border-radius: 28px;
      padding: 36px;
      box-shadow: 0 40px 120px rgba(0,0,0,0.6);
    }
    .menu h2 { font-size: 42px; margin: 0 0 12px 0; }
    .menu p { font-size: 28px; color: var(--text-dim); margin: 0 0 24px 0; }
    .menu-list { display: grid; gap: 12px; }
    .menu-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      font-size: 32px;
      background: #1a1a1a;
      border: 2px solid #242424;
      border-radius: 16px;
      padding: 18px 22px;
    }
    .menu-item.selected {
      border-color: var(--accent);
      box-shadow: inset 0 0 0 4px var(--accent);
      background: rgba(0,212,255,0.12);
    }

    .sr-only { position: absolute; left: -9999px; width: 1px; height: 1px; overflow: hidden; }
  </style>
</head>
<body>
  <div class="tv-stage">
    <div class="canvas-16x9" role="application" aria-label="Tic Tac Toe for TV">
      <header>
        <div class="title">Tic Tac Toe</div>
        <div class="controls-hint">Use ▲ ▼ ◄ ► to move • Enter to place • Esc for Menu</div>
      </header>

      <div class="main">
        <section class="info-panel" aria-live="polite">
          <div id="status" class="status">Player X's turn</div>
          <div id="substatus" class="substatus">Navigate with arrow keys. Press Enter to mark a cell.</div>
        </section>

        <section id="grid" class="grid" aria-label="Game board" aria-live="off"></section>
      </div>

      <footer>
        <div>1080p TV Experience • High-contrast • Remote-only controls</div>
        <div>Press Esc to open menu</div>
      </footer>
    </div>
  </div>

  <div id="overlay" class="overlay" aria-hidden="true">
    <div class="menu" role="dialog" aria-modal="true" aria-label="Game Menu">
      <h2>Game Menu</h2>
      <p>Use ▲ ▼ to select • Enter to confirm • Esc to close</p>
      <div id="menu-list" class="menu-list"></div>
    </div>
  </div>

  <div id="aria-status" class="sr-only" aria-live="polite"></div>

  <script>
    // --- Audio: light-weight Web Audio kit for tiny SFX ---
    const AudioKit = (() => {
      let ctx;
      function context() {
        if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
        return ctx;
      }
      function resume() { return context().resume ? context().resume() : Promise.resolve(); }

      function tone({ freq=440, type='sine', dur=0.08, gain=0.08, attack=0.002, release=0.04, when=0 }) {
        const c = context();
        const t0 = c.currentTime + when;
        const osc = c.createOscillator();
        const g = c.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, t0);
        g.gain.setValueAtTime(0, t0);
        g.gain.linearRampToValueAtTime(gain, t0 + attack);
        g.gain.linearRampToValueAtTime(0.0001, t0 + dur + release);
        osc.connect(g).connect(c.destination);
        osc.start(t0);
        osc.stop(t0 + dur + release + 0.02);
      }

      function clickUI(dir=1) {
        // Subtle nav tick up/down
        tone({ freq: dir > 0 ? 1150 : 950, type: 'square', dur: 0.035, gain: 0.04, attack: 0.001, release: 0.03 });
      }

      function confirmUI() {
        tone({ freq: 880, type: 'triangle', dur: 0.06, gain: 0.06 });
        tone({ freq: 1320, type: 'triangle', dur: 0.06, gain: 0.05, when: 0.05 });
      }

      function invalid() {
        tone({ freq: 180, type: 'sawtooth', dur: 0.08, gain: 0.06 });
      }

      function moveX() {
        // Bright, slightly higher
        tone({ freq: 920, type: 'triangle', dur: 0.05, gain: 0.06 });
      }

      function moveO() {
        // Slightly lower
        tone({ freq: 760, type: 'triangle', dur: 0.05, gain: 0.06 });
      }

      function win() {
        // Quick arpeggio
        const base = 660;
        [0, 0.08, 0.16].forEach((offset, i) =>
          tone({ freq: base * (i===0?1: i===1?1.25:1.5), type: 'sine', dur: 0.08, gain: 0.07, when: offset })
        );
      }

      function draw() {
        tone({ freq: 520, type: 'sine', dur: 0.12, gain: 0.06 });
      }

      return { resume, tone, clickUI, confirmUI, invalid, moveX, moveO, win, draw };
    })();

    (function() {
      const gridEl = document.getElementById('grid');
      const statusEl = document.getElementById('status');
      const substatusEl = document.getElementById('substatus');
      const overlayEl = document.getElementById('overlay');
      const menuListEl = document.getElementById('menu-list');
      const ariaStatusEl = document.getElementById('aria-status');

      const state = {
        board: Array(9).fill(null),
        selected: 4,
        player: 'X',
        gameOver: false,
        winner: null,
        winningLine: null,
        menuOpen: false,
        menuIndex: 0
      };

      const MENU_ITEMS_PLAYING = [
        { id: 'resume', label: 'Resume' },
        { id: 'new', label: 'New Game' },
        { id: 'quit', label: 'Quit (Clear Board)' },
      ];
      const MENU_ITEMS_OVER = [
        { id: 'new', label: 'New Game' },
        { id: 'quit', label: 'Quit (Clear Board)' },
      ];

      const cells = [];
      for (let i = 0; i < 9; i++) {
        const c = document.createElement('div');
        c.className = 'cell';
        c.setAttribute('role', 'button');
        c.setAttribute('aria-label', 'Empty cell');
        c.dataset.index = i;
        c.addEventListener('click', (e) => e.preventDefault(), { passive: true });
        gridEl.appendChild(c);
        cells.push(c);
      }

      function announce(text) { ariaStatusEl.textContent = text; }
      function setStatus(text, sub="") {
        statusEl.textContent = text;
        substatusEl.textContent = sub;
        announce(text + (sub ? ('. ' + sub) : ''));
      }

      function render() {
        for (let i = 0; i < 9; i++) {
          const v = state.board[i];
          const el = cells[i];
          el.textContent = v ? v : '';
          el.classList.remove('X', 'O', 'selected', 'winning');
          if (v) el.classList.add(v);
          if (state.selected === i && !state.menuOpen) el.classList.add('selected');
          if (state.winningLine && state.winningLine.includes(i)) el.classList.add('winning');

          const label = v ? `Cell ${i+1} ${v}` : `Cell ${i+1} empty`;
          el.setAttribute('aria-label', label);
        }

        if (state.gameOver) {
          if (state.winner) {
            setStatus(`${state.winner} wins!`, 'Press Enter for a new game or Esc for menu.');
          } else {
            setStatus('Draw!', 'Press Enter for a new game or Esc for menu.');
          }
        } else {
          setStatus(`Player ${state.player}'s turn`, 'Use arrows to move. Enter to place. Esc for menu.');
        }

        overlayEl.classList.toggle('show', state.menuOpen);
        overlayEl.setAttribute('aria-hidden', state.menuOpen ? 'false' : 'true');

        const items = state.gameOver ? MENU_ITEMS_OVER : MENU_ITEMS_PLAYING;
        menuListEl.innerHTML = '';
        items.forEach((item, idx) => {
          const el = document.createElement('div');
          el.className = 'menu-item' + (idx === state.menuIndex ? ' selected' : '');
          el.textContent = item.label;
          el.dataset.id = item.id;
          menuListEl.appendChild(el);
        });
      }

      function checkWin(board) {
        const lines = [
          [0,1,2],[3,4,5],[6,7,8],
          [0,3,6],[1,4,7],[2,5,8],
          [0,4,8],[2,4,6]
        ];
        for (const line of lines) {
          const [a,b,c] = line;
          if (board[a] && board[a] === board[b] && board[b] === board[c]) {
            return { winner: board[a], line };
          }
        }
        if (board.every(Boolean)) return { winner: null, line: null, draw: true };
        return null;
      }

      function endGameEffects(result) {
        if (result.draw) {
          AudioKit.draw();
        } else {
          AudioKit.win();
        }
      }

      function placeAt(index) {
        if (state.gameOver) {
          newGame();
          return;
        }
        if (state.board[index]) {
          // occupied
          cells[index].style.transform = 'scale(1.04)';
          setTimeout(() => { cells[index].style.transform = ''; }, 120);
          AudioKit.invalid();
          announce('Cell occupied');
          return;
        }

        // Ensure audio context is running (often needed on TVs/browsers)
        AudioKit.resume();

        state.board[index] = state.player;
        // Play per-player move sound
        if (state.player === 'X') AudioKit.moveX(); else AudioKit.moveO();

        const res = checkWin(state.board);
        if (res) {
          if (res.draw) {
            state.gameOver = true;
            state.winner = null;
            state.winningLine = null;
            endGameEffects({ draw: true });
          } else {
            state.gameOver = true;
            state.winner = res.winner;
            state.winningLine = res.line;
            endGameEffects({ draw: false });
          }
        } else {
          state.player = state.player === 'X' ? 'O' : 'X';
          if (state.board[state.selected]) {
            let next = state.selected;
            for (let i = 0; i < 9; i++) {
              next = (next + 1) % 9;
              if (!state.board[next]) { state.selected = next; break; }
            }
          }
        }
        render();
      }

      function newGame() {
        state.board = Array(9).fill(null);
        state.player = 'X';
        state.gameOver = false;
        state.winner = null;
        state.winningLine = null;
        state.selected = 4;
        render();
      }

      function quitGame() {
        state.board = Array(9).fill(null);
        state.player = 'X';
        state.gameOver = false;
        state.winner = null;
        state.winningLine = null;
        state.selected = 4;
        state.menuOpen = false;
        render();
      }

      function toggleMenu(open) {
        state.menuOpen = (open === undefined) ? !state.menuOpen : !!open;
        state.menuIndex = 0;
        render();
        announce(state.menuOpen ? 'Menu opened' : 'Menu closed');
        if (state.menuOpen) AudioKit.clickUI(1);
      }

      function moveSelection(dx, dy) {
        if (state.menuOpen) {
          const items = state.gameOver ? MENU_ITEMS_OVER : MENU_ITEMS_PLAYING;
          if (dy !== 0) {
            state.menuIndex = (state.menuIndex + dy + items.length) % items.length;
            AudioKit.clickUI(dy);
            render();
          }
          return;
        }
        let row = Math.floor(state.selected / 3);
        let col = state.selected % 3;
        row = (row + dy + 3) % 3;
        col = (col + dx + 3) % 3;
        state.selected = row * 3 + col;
        AudioKit.clickUI(dy !== 0 ? dy : (dx !== 0 ? dx : 1));
        render();
      }

      function activateSelection() {
        if (state.menuOpen) {
          const items = state.gameOver ? MENU_ITEMS_OVER : MENU_ITEMS_PLAYING;
          const id = items[state.menuIndex].id;
          AudioKit.confirmUI();
          if (id === 'resume') toggleMenu(false);
          if (id === 'new') { toggleMenu(false); newGame(); }
          if (id === 'quit') { toggleMenu(false); quitGame(); }
          return;
        }
        placeAt(state.selected);
      }

      function onKey(e) {
        const code = e.code;
        if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Enter','Escape'].includes(code)) {
          e.preventDefault();
        }
        switch (code) {
          case 'ArrowUp':   moveSelection(0, -1); break;
          case 'ArrowDown': moveSelection(0, +1); break;
          case 'ArrowLeft': moveSelection(-1, 0); break;
          case 'ArrowRight':moveSelection(+1, 0); break;
          case 'Enter':     activateSelection(); break;
          case 'Escape':    toggleMenu(); break;
        }
      }

      window.addEventListener('keydown', onKey);

      render();
    })();
  </script>
</body>
</html>
``
